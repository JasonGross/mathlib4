import Mathlib

open CFC NNReal

local notation "σ" => spectrum

section canLift

variable {R S A : Type*}

variable [Semifield R] [Semifield S] [Ring A] [Algebra R A] [Algebra S A] [Algebra R S]
variable [IsScalarTower R S A] (a : A) (f : S → R)

#check spectrum.algebraMap_mem
#check Subtype.map
#check Set.inclusion

---lemma SpectrumRestricts.canLift (h : SpectrumRestricts a f) :
    ---CanLift (spectrum S a) (spectrum R a) (Set.inclusion (spectrum.algebraMap_mem (R := R) (S := S) (a := a))) := by
  ---intro x
  ---rw [← h x]
  ---exact rfl

end canLift

section prereq

lemma ContinuousOn.ofReal_map_toNNReal {f : ℝ≥0 → ℝ≥0} {s : Set ℝ} {t : Set ℝ≥0}
    (hf : ContinuousOn f t) (h : Set.MapsTo Real.toNNReal s t) :
    ContinuousOn (fun x ↦ f x.toNNReal : ℝ → ℝ) s :=
  continuous_subtype_val.comp_continuousOn <| hf.comp continuous_real_toNNReal.continuousOn h

lemma cfc_nnreal_le_iff {A : Type*} [TopologicalSpace A] [Ring A] [StarRing A] [PartialOrder A]
    [StarOrderedRing A] [Algebra ℝ A] [TopologicalRing A] [NonnegSpectrumClass ℝ A]
    [ContinuousFunctionalCalculus ℝ (IsSelfAdjoint : A → Prop)]
    [UniqueContinuousFunctionalCalculus ℝ A]
    [∀ a : A, CompactSpace (σ ℝ a)]
    (f : ℝ≥0 → ℝ≥0) (g : ℝ≥0 → ℝ≥0) (a : A)
    (ha_spec : SpectrumRestricts a ContinuousMap.realToNNReal)
    (hf : ContinuousOn f (σ ℝ≥0 a) := by cfc_cont_tac)
    (hg : ContinuousOn g (σ ℝ≥0 a) := by cfc_cont_tac)
    (ha : 0 ≤ a := by cfc_tac) :
    cfc f a ≤ cfc g a ↔ ∀ x ∈ σ ℝ≥0 a, f x ≤ g x := by
  have hf' := hf.ofReal_map_toNNReal <| ha_spec.image ▸ Set.mapsTo_image ..
  have hg' := hg.ofReal_map_toNNReal <| ha_spec.image ▸ Set.mapsTo_image ..
  rw [cfc_nnreal_eq_real, cfc_nnreal_eq_real, cfc_le_iff ..]
  simp [coe_le_coe, ← ha_spec.image]

end prereq

variable {A : Type*} [NormedRing A] [NormedAlgebra ℂ A] [StarRing A] [CStarRing A] [CompleteSpace A]
variable [StarModule ℂ A] [PartialOrder A] [StarOrderedRing A]

example {a : Aˣ} (ha : (0 : A) ≤ a := by cfc_tac) : (0 : A) ≤ a⁻¹ :=
  inv_nonneg_of_nonneg a ha

@[simp]
lemma Units.zero_not_mem_spectrum (R : Type*) {A : Type*} [CommSemiring R] [Ring A] [Algebra R A]
    (a : Aˣ) : 0 ∉ spectrum R (a : A) :=
  spectrum.zero_not_mem R a.isUnit

lemma CFC.conjugate_rpow_neg_one_half {a : A} (h₀ : 0 ∉ spectrum ℝ≥0 a) (ha : 0 ≤ a := by cfc_tac) :
    a ^ (-1 / 2 : ℝ) * a * a ^ (-1 / 2 : ℝ) = 1 := by
  lift a to Aˣ using spectrum.isUnit_of_zero_not_mem ℝ≥0 h₀
  nth_rw 2 [← rpow_one (a : A)]
  simp only [← rpow_add (a.zero_not_mem_spectrum ℝ≥0)]
  norm_num
  exact rpow_zero _

lemma IsSelfAdjoint.mul_left_right_nonneg {a b : A} (ha : IsSelfAdjoint a) (hb : 0 ≤ b) :
    0 ≤ a * b * a := by
  simpa only [ha.star_eq] using conjugate_nonneg hb a

lemma StarOrderedRing.mul_left_right_nonneg {a b : A} (ha : 0 ≤ a) (hb : 0 ≤ b) :
    0 ≤ a * b * a :=
  IsSelfAdjoint.of_nonneg ha |>.mul_left_right_nonneg hb

-- this should be about strict positivity? Essentially, we're just saying that if `a` is strictly
-- positive, and `b` is greater than `a`, then `b` is strictly positive, since `a` is in the
-- heriditary C⋆-subalgebra generated by `b`.
lemma CFC.zero_not_mem_spectrum {a b : A} (h₀ : 0 ∉ spectrum ℝ≥0 a) (ha : 0 ≤ a := by cfc_tac)
    (hab : a ≤ b) : 0 ∉ spectrum ℝ≥0 b := by
  have := conjugate_le_conjugate hab (a ^ (-1 / 2 : ℝ))
  have ha₁ : IsSelfAdjoint (a ^ (-1 / 2 : ℝ)) := .of_nonneg rpow_nonneg
  rw [ha₁.star_eq, conjugate_rpow_neg_one_half h₀] at this
  have haba : 0 ≤ a ^ (-1 / 2 : ℝ) * b * a ^ (-1 / 2 : ℝ) :=
    ha₁.mul_left_right_nonneg <| ha.trans hab
  rw [← cfc_id ℝ≥0 _ haba, ← cfc_const_one ℝ≥0 _ haba,
    cfc_nnreal_le_iff _ _ _ (QuasispectrumRestricts.nnreal_of_nonneg haba)] at this
  have : 0 ∉ spectrum ℝ≥0 (a ^ (-1 / 2 : ℝ) * b * a ^ (-1 / 2 : ℝ)) := (one_pos.not_le <| this 0 ·)
  have ha₂ := h₀
  rw [spectrum.zero_not_mem_iff] at ha₂ this ⊢
  rw [← CFC.sq_sqrt a, sq, CFC.sqrt_eq_rpow, isUnit_mul_self_iff] at ha₂
  have foo := ha₂.mul this |>.mul ha₂
  rw [← mul_assoc, ← mul_assoc, ← rpow_add h₀, mul_assoc, ← rpow_add h₀] at foo
  norm_num at foo
  simpa [CFC.rpow_zero a] using foo

protected lemma CFC.inv_le_inv {a b : Aˣ} (ha : 0 ≤ (a : A)) (hb : 0 ≤ (b : A))
    (hab : (a : A) ≤ b) : (↑a⁻¹ : A) ≤ b⁻¹ := by
  have hb_inv : (0 : A) ≤ b⁻¹ := inv_nonneg_of_nonneg b hb
  have ha_inv : (0 : A) ≤ a⁻¹ := inv_nonneg_of_nonneg a ha
  have hb₁ : IsSelfAdjoint ((b : A) ^ (-1 / 2 : ℝ)) := .of_nonneg rpow_nonneg
  have := conjugate_le_conjugate hab (b ^ (-1 / 2 : ℝ))
  rw [hb₁.star_eq, conjugate_rpow_neg_one_half (b.zero_not_mem_spectrum ℝ≥0)] at this

  sorry
